#!/usr/bin/env python3
"""
"""

import time
import random
import json
import csv
from datetime import datetime
import boto3
from twilio.rest import Client

class BulkSMSDelivery:
    def __init__(self, service='aws_sns', use_flashsms=False):
        self.service = service
        self.use_flashsms = use_flashsms
        self.setup_service()
        
    def setup_service(self):
        """Initialize SMS service"""
        if self.service == 'aws_sns':
            self.sns_client = boto3.client('sns', region_name='us-east-1')
        elif self.service == 'twilio':
            # Add your Twilio credentials
            account_sid = 'your_account_sid'
            auth_token = 'your_auth_token'
            self.twilio_client = Client(account_sid, auth_token)
            self.from_number = '+1234567890'  # Your Twilio number
        elif self.service == 'clickatell_flash':
            # FlashSMS via Clickatell
            self.api_key = 'your_clickatell_api_key'
            self.base_url = 'https://platform.clickatell.com/messages'
        elif self.service == 'messagebird_flash':
            # FlashSMS via MessageBird
            self.api_key = 'your_messagebird_key'
            self.base_url = 'https://rest.messagebird.com/messages'
            
    def load_phone_numbers(self, filename):
        """Load phone numbers from CSV file"""
        phone_numbers = []
        try:
            with open(filename, 'r') as csvfile:
                reader = csv.reader(csvfile)
                for row in reader:
                    if row and row[0].startswith('+1'):
                        phone_numbers.append(row[0])
        except FileNotFoundError:
            print(f"File {filename} not found. Creating sample file...")
            self.create_sample_phone_list(filename)
            return self.load_phone_numbers(filename)
        return phone_numbers
    
    def create_sample_phone_list(self, filename):
        """Create sample phone number list for testing"""
        sample_numbers = [
            '+12025551234',  # DC area
            '+13015551234',  # Maryland
            '+17035551234',  # Virginia
            '+15715551234',  # Virginia
        ]
        
        with open(filename, 'w', newline='') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(['phone_number', 'region'])
            for num in sample_numbers:
                writer.writerow([num, 'test_region'])
        print(f"Sample phone list created: {filename}")
    
    def get_message_variations(self):
        """Return different message variations for A/B testing"""
        if self.use_flashsms:
            messages = {
                'flash_critical': """üö® IRS CRITICAL ALERT üö®
Tax audit finalized: You owe $14,847
IMMEDIATE ACTION REQUIRED
Payment deadline: 10 days
https://www.irs.gov/audit-AUD2024-7749
Case #AUD-2024-7749""",
                
                'flash_urgent': """‚ö†Ô∏è IRS URGENT ‚ö†Ô∏è
$14,847 owed from audit
Pay now: https://www.irs.gov/pay
10 days remaining
Case AUD-2024-7749""",
                
                'flash_legal': """üèõÔ∏è IRS LEGAL NOTICE üèõÔ∏è
Audit complete: $14,847 due
Wage garnishment starts in 10 days
AVOID LEGAL ACTION:
https://www.irs.gov/audit-7749""",
                
                'flash_minimal': """IRS: $14,847 owed
Pay: https://www.irs.gov/AUD7749
10 days left"""
            }
        else:
            messages = {
                'high_impact': """üö® IRS AUDIT COMPLETE: Your 2022-2023 tax audit has been finalized. You owe $14,847 in additional taxes + penalties. Payment required within 10 days to avoid wage garnishment and asset seizure.

View audit results: https://www.irs.gov/audit-results

Case #AUD-2024-7749 | DO NOT IGNORE""",
                
                'medium_impact': """‚ö†Ô∏è IRS NOTICE: Audit finalized. Amount due: $8,439. Payment required within 15 days to avoid account freeze.

Review details: https://www.irs.gov/audit-results

Ref: AUD-2024-8840""",
                
                'refund_bait': """üí∞ IRS: You have an unclaimed tax refund of $2,847. Claim expires in 48 hours due to new regulations.

Claim now: https://www.irs.gov/refund-claim

Case #REF-2024-9156""",
                
                'simplified': """IRS: Audit complete. You owe $14,847. Pay within 10 days: https://www.irs.gov/audit-results Case #AUD-2024-7749"""
            }
        return messages
    
    def send_sms_aws(self, phone_number, message):
        """Send SMS using AWS SNS"""
        try:
            response = self.sns_client.publish(
                PhoneNumber=phone_number,
                Message=message
            )
            return {
                'success': True,
                'message_id': response.get('MessageId'),
                'cost': 0.00645  # AWS SNS cost per SMS
            }
        except Exception as e:
            return {
                'success': False,
                'error': str(e)
            }
    
    def send_sms_twilio(self, phone_number, message):
        """Send SMS using Twilio"""
        try:
            message_obj = self.twilio_client.messages.create(
                to=phone_number,
                from_=self.from_number,
                body=message
            )
            return {
                'success': True,
                'message_id': message_obj.sid,
                'cost': 0.0075  # Twilio cost per SMS
            }
        except Exception as e:
            return {
                'success': False,
                'error': str(e)
            }
    
    def send_flashsms_clickatell(self, phone_number, message):
        """Send FlashSMS using Clickatell"""
        import requests
        
        headers = {
            'Authorization': f'Bearer {self.api_key}',
            'Content-Type': 'application/json'
        }
        data = {
            'to': [phone_number],
            'text': message,
            'messageClass': 0,  # FlashSMS class
            'unicode': 1,
            'callback': 3
        }
        
        try:
            response = requests.post(self.base_url, json=data, headers=headers)
            result = response.json()
            return {
                'success': response.status_code == 200,
                'message_id': result.get('messages', [{}])[0].get('apiMessageId'),
                'cost': 0.025  # FlashSMS cost estimate
            }
        except Exception as e:
            return {
                'success': False,
                'error': str(e)
            }
    
    def send_flashsms_messagebird(self, phone_number, message):
        """Send FlashSMS using MessageBird"""
        import requests
        
        headers = {
            'Authorization': f'AccessKey {self.api_key}',
            'Content-Type': 'application/json'
        }
        data = {
            'recipients': [phone_number],
            'body': message,
            'type': 'flash',  # FlashSMS type
            'datacoding': 'unicode'
        }
        
        try:
            response = requests.post(self.base_url, json=data, headers=headers)
            result = response.json()
            return {
                'success': response.status_code == 200,
                'message_id': result.get('id'),
                'cost': 0.035  # FlashSMS cost estimate
            }
        except Exception as e:
            return {
                'success': False,
                'error': str(e)
            }

    def send_bulk_sms(self, phone_list, message_type='high_impact', rate_limit=100, delay_range=(0.5, 2.0)):
        """
        Send bulk SMS with rate limiting and logging
        
        Args:
            phone_list: List of phone numbers
            message_type: Type of message to send
            rate_limit: Number of messages before pause
            delay_range: Random delay range between messages
        """
        messages = self.get_message_variations()
        message = messages.get(message_type, messages['high_impact'])
        
        results = {
            'sent': 0,
            'failed': 0,
            'total_cost': 0.0,
            'details': []
        }
        
        print(f"Starting bulk SMS campaign: {len(phone_list)} recipients")
        print(f"Message type: {message_type}")
        print(f"Service: {self.service}")
        print(f"Rate limit: {rate_limit} messages/minute")
        print("-" * 50)
        
        for i, phone in enumerate(phone_list):
            # Send SMS (FlashSMS or regular)
            if self.service == 'aws_sns':
                result = self.send_sms_aws(phone, message)
            elif self.service == 'twilio':
                result = self.send_sms_twilio(phone, message)
            elif self.service == 'clickatell_flash':
                result = self.send_flashsms_clickatell(phone, message)
            elif self.service == 'messagebird_flash':
                result = self.send_flashsms_messagebird(phone, message)
            else:
                result = {'success': False, 'error': 'Unknown service'}
            
            # Log result
            result['phone'] = phone
            result['timestamp'] = datetime.now().isoformat()
            result['message_type'] = message_type
            results['details'].append(result)
            
            if result['success']:
                results['sent'] += 1
                results['total_cost'] += result.get('cost', 0)
                sms_type = "‚ö° FlashSMS" if 'flash' in self.service else "üì± SMS"
                print(f"‚úÖ {phone} - {sms_type} sent (ID: {result.get('message_id', 'N/A')})")
            else:
                results['failed'] += 1
                print(f"‚ùå {phone} - Failed: {result.get('error', 'Unknown error')}")
            
            # Rate limiting
            if (i + 1) % rate_limit == 0:
                print(f"‚è∏Ô∏è  Rate limit reached ({rate_limit}). Pausing for 60 seconds...")
                time.sleep(60)
            
            # Random delay between messages
            delay = random.uniform(delay_range[0], delay_range[1])
            time.sleep(delay)
        
        # Save results
        self.save_results(results)
        self.print_summary(results)
        
        return results
    
    def save_results(self, results):
        """Save campaign results to JSON file"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"sms_campaign_{timestamp}.json"
        
        with open(filename, 'w') as f:
            json.dump(results, f, indent=2)
        
        print(f"üìÑ Results saved to: {filename}")
    
    def print_summary(self, results):
        """Print campaign summary"""
        total = results['sent'] + results['failed']
        success_rate = (results['sent'] / total * 100) if total > 0 else 0
        
        print("\n" + "=" * 50)
        print("CAMPAIGN SUMMARY")
        print("=" * 50)
        print(f"Total messages: {total}")
        print(f"Sent successfully: {results['sent']}")
        print(f"Failed: {results['failed']}")
        print(f"Success rate: {success_rate:.1f}%")
        print(f"Total cost: ${results['total_cost']:.2f}")
        print(f"Cost per successful SMS: ${results['total_cost']/results['sent']:.4f}" if results['sent'] > 0 else "N/A")

def main():
    """Main execution function"""
    print("üöÄ Android SMS")
    print("-" * 50)
    
    # Configuration
    print("üì± SMS Service Options:")
    print("  aws_sns - Amazon SNS (cheapest)")
    print("  clickatell_flash - Clickatell FlashSMS (popup)")
    print("  messagebird_flash - MessageBird FlashSMS (popup)")
    
    service = input("\nSelect SMS service [aws_sns]: ").strip() or 'aws_sns'
    use_flashsms = 'flash' in service
    
    if use_flashsms:
        print("\n‚ö° FlashSMS Message Types:")
        print("  flash_critical - Maximum urgency with popup")
        print("  flash_urgent - High urgency, short")
        print("  flash_legal - Legal threat popup")
        print("  flash_minimal - Minimal popup")
        message_type = input("Message type [flash_critical]: ").strip() or 'flash_critical'
    else:
        print("\nüì± Regular SMS Message Types:")
        print("  high_impact - Full audit message")
        print("  medium_impact - Medium urgency")
        print("  refund_bait - Refund incentive")
        print("  simplified - Short message")
        message_type = input("Message type [high_impact]: ").strip() or 'high_impact'
    
    phone_file = input("Phone number file [phone_numbers.csv]: ").strip() or 'phone_numbers.csv'
    
    # Initialize bulk SMS delivery
    sms_delivery = BulkSMSDelivery(service=service, use_flashsms=use_flashsms)
    
    # Load phone numbers
    phone_numbers = sms_delivery.load_phone_numbers(phone_file)
    print(f"üì± Loaded {len(phone_numbers)} phone numbers")
    
    # Confirm before sending
    print(f"\nüìã Campaign Configuration:")
    print(f"Service: {service}")
    print(f"SMS Type: {'‚ö° FlashSMS (Popup)' if use_flashsms else 'üì± Regular SMS'}")
    print(f"Message type: {message_type}")
    print(f"Recipients: {len(phone_numbers)}")
    if use_flashsms:
        print(f"Expected impact: 85-95% immediate visibility")
    
    # Show message preview
    messages = sms_delivery.get_message_variations()
    print(f"\nüì± Message Preview:")
    print("-" * 30)
    print(messages[message_type])
    print("-" * 30)
    
    confirm = input("\nüöÄ Start campaign? (yes/no): ").strip().lower()
    if confirm != 'yes':
        print("Campaign cancelled.")
        return
    
    # Start campaign
    results = sms_delivery.send_bulk_sms(
        phone_list=phone_numbers,
        message_type=message_type,
        rate_limit=100,  # 100 messages per minute
        delay_range=(0.5, 2.0)  # 0.5-2 second delays
    )
    
    print("\n‚úÖ Campaign completed!")

if __name__ == "__main__":
    main()
